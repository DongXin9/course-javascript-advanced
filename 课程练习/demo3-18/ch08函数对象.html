<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>
<script>
        // typeof new Data();//"object"
        // typeof new Array();//"object"
        // function fn1(){

        // }
        // typeof fn1;//function
    
    //对象 instanceof 构造函数
    // 1、判断对象是否可以使用构造函数实例化得到
    function Person(username,age){
        this.username = username;
        this.age = age;
    }
    var person = new Person("zhangsan",20);
    console.log(person);
    person instanceof Person;
    // 2、判断在对象的原型链上能否找到构造函数的prototype属性
    function Person(username,age){
        this.username = username;
        this.age = age;
    }
    var person = new Person("zhangsan",20);
    console.log(person);
    console.log(person._proto_ == Person.prototype);
    console.log(person._proto_._proto_ == object.prototype);

    person instanceof Person;

    //对象的属性和操作方法
    function fn1(){
        //length表示是函数的形参个数
        //argument是函数调用时，实参类型集合
        console.log(fn1,le1);
        for(var i = 0;i < arguments.length;i++){
            console.log(arguments[i]);
        }
    }

    function fn1(){
        console.log(fn1.caller);
    }
    function fn2(){
        fn1();
    }
    fn2();

    //匿名函数的递归调用
    //arguments.callee 
    var func =function(n){
        if(n <= 0){
            return 1;
        }
        else
        //return n * func(n-1);
        return n * arguments.callee(n - 1);
    }
    console.log(func(4));




    var objA = {"objName": "AAA"};
    var objB = {"objName": "BBB"};
    objA.foo = function(){
        console.log(this.objName);
    }
    objA.foo();
    //方法.call();
    objA.foo.call(objA);

    function Person(username,age){
        this.username=username;
        this.age=age;
    }
    function Student(username,age,sex){
        Person.call(this,username,age);
        this.sex=sex;
    }
    var student = new Student("zhangsan",20,"sale");
         //swim.call(对象，参数，参数)
        function swim(m, n) {
            console.log(this.name, m, n);
        }
        var bird = {
            name:"polly",
            fly:function(m, n) {
                console.log(this.name, m, n);
            }
        };
        var me = {
            name:"ABC"
        };
        swim.call(me, "hello", "world");
        swim.call(bird, "hello", "world");

        //apply
        //swim.apply(bird, ["hello", "world"]);


        //bind切换函数的this指向，但是不会立刻执行
        //而是会生成一个新的函数、
        var swim1 = swim.bind(brid);




        var objName="obj2";
        var obj = {
            "objName":"obj1",
            "show": function(){
                function fn1(){
                    console.log(this.objName);
                }
                fn1();
            }
        }
        obj.show();








</script>
</body>
</html>